\documentclass{scrreprt}

% Equations
\usepackage{amsmath}

% List customization
\usepackage[inline]{enumitem}

% They are all over the place
\usepackage{todonotes}

% Diagrams
\usepackage{tikz}
\usetikzlibrary{arrows,positioning}

% Appendices
\usepackage[header,title,titletoc]{appendix}
\renewcommand{\appendixname}{Appendix}

% License
\usepackage[
    type={CC},
    modifier={by-sa},
    version={3.0},
]{doclicense}

% Add bibliography to TOC
\usepackage[nottoc,numbib]{tocbibind}

% Sane datestamps
\usepackage[yyyymmdd]{datetime}
\renewcommand{\dateseparator}{--}

% Math symbols
\usepackage{amssymb}

% Haskell code highlighting
\usepackage{minted}
\newenvironment{code}{\VerbatimEnvironment\begin{minted}{haskell}}{\end{minted}}
\setminted{fontsize=\small,baselinestretch=1}

% Include images
\usepackage{graphics}

% No new page on chapters
\usepackage{etoolbox}
\makeatletter
\patchcmd{\scr@startchapter}{\if@openright\cleardoublepage\else\clearpage\fi}{}{}{}
\makeatother

\begin{document}

\title{Supporting Competent Authorities in the Implementation of the NIS
Directive for Safety-Critical Industries}
\subtitle{Analysis through attack-defense trees}
\author{Uma Zalakain \\ \href{mailto:2423394z@student.gla.ac.uk}{2423394z@student.gla.ac.uk}}

{\let\newpage\relax\maketitle}
\doclicenseThis
\newpage

\pagenumbering{roman}
\setcounter{tocdepth}{2}
\tableofcontents
\newpage
\pagenumbering{arabic}

\chapter{Introduction}

The EU directive on the security of Networks and Information Systems (NIS) has
been integrated into UK law. This directive aims to improve the reliability and
security of those network and information systems that are essential to the
economy, society and individual's
welfare.\footnote{\url{https://www.ncsc.gov.uk/guidance/introduction-nis-directive}}

The NIS directive does not require Operators of Essential Services (OES) to
conform to a particular set of fixed rules. Instead, it hands the responsibility
of oversight to the relevant Competent Authority (CA). The NIS directive
postulates 14 general
principles\footnote{\url{https://www.ncsc.gov.uk/guidance/table-view-principles-and-related-guidance}}
-- CAs are strongly
encouraged\footnote{\url{https://www.gov.uk/government/publications/nis-regulations-guidance-for-competent-authorities}}
to use the Cyber Assessment
Framework\footnote{\url{https://www.ncsc.gov.uk/guidance/nis-directive-cyber-assessment-framework}}
to evaluate whether OES follow them. Depending on the sector, a CA may issue
more specific guidance. One such example is the guidance for Cyber Security for
Industrial Automation and Control
Systems\footnote{\url{http://www.hse.gov.uk/foi/internalops/og/og-0086.pdf}}
issued by the Health and Safety Executive.

\section{Contributions}

In \S\ref{tool} I present \textit{ADTrees}, a Haskell library capable of
\textbf{modelling}, \textbf{rendering}, finding \textbf{minimal cutsets} and
performing \textbf{quantitative analysis} on attack defense trees.

I then demonstrate how a CA might use this tool to guide an asses an OES by
performing a case analysis in \S\ref{evaluation} on the provision of the
top-level domain \texttt{.uk} by the provider
Nominet\footnote{\url{https://nominet.uk}} -- where Ofcom is the competent
authority as the designated regulator for digital infrastructure.

\todo{Introduce other sections}
\todo{Warn familiarity with Haskell}

Concretely, the library eases the evaluation of the following points of the
Cyber Assessment Framework:

\todo{revise these are met in evaluation}
\begin{description}
    \item [A2a]
        \begin{itemize}
            \item Your organisational process ensures that security risks to
                networks and information systems relevant to essential services
                are identified, analysed, prioritised, and managed.
            \item Your approach to risk is focused on the possibility of
                disruption to your essential service, leading to a detailed
                understanding of how such disruption might arise as a
                consequence of possible attacker actions and the security
                properties of your networks and information systems.
            \item The output from your risk management process is a clear set of
                security requirements that will address the risks in line with
                your organisational approach to security.
        \end{itemize}

    \item [B1a]
        \begin{itemize}
            \item Your systems are designed so that they remain secure even when
                user security policies and processes are not always followed.
        \end{itemize}
\end{description}

\chapter{A Haskell library for attack defense trees}
\label{tool}

\section{Attack defense trees}

Fault trees were first introduced as a graphical and logical tool for modelling
the way in which basic events interact to lead to an undesired behaviour
\cite[IV.1]{Vesely1981}. They are therefore useful in safety-critical systems.
They consist of nodes and leafs: each node is a logical gate; each leaf a basic
event. This structure makes fault trees attractive for quantitative evaluation.
It is important to note that all basic events in a fault tree \textit{must} be
unique and independent. If not the case, every directed acyclic graph
representing a fault model can be rewritten as a fault tree.  \todo{citation
needed}

Attack trees take the idea of fault trees and adapt it to model attack scenarios
in security-critical systems \cite{Schneier1999} \cite{Brooke2003}
\cite{NaiFovino2009}: an attacker's objective (at the root of the tree) is
repeatedly refined into subgoals connected by logical gates. Yet, this model is
unable to represent any defensive measure.

\begin{figure}[h!]
    \label{example-adt}
    \centering
    \includegraphics[width=\textwidth]{bankaccount}
    \caption{Example attack defense tree generated by ADTrees. Red nodes
    represent the attacker's actions, green nodes the defendant's. Basic events
    contain multiple attributes for quantitative analysis.}
\end{figure}

Attack defense trees (ADTs) extend attack trees by introducing nodes that
represent defensive measures \cite{KordyFoundations}. Every node is thus an
action of either the attacker or the defender: interactive scenarios can be
represented.  As with fault trees, refinements can either be disjunctive or
conjunctive. To allow a quantitative evaluation of ADTs, nodes have to be
independent of each other -- alternative proposals relying on DAGs exist, but
are more complex \cite{KordyDAG}.

\todo{More on the technique itself?}

% TODO: relate to NIS: CAF points
%   IMPORTANT: How attack defense trees help

\section{ADTrees}

\textit{ADTrees}\footnote{\url{https://github.com/umazalakain/adtrees}}
is a small Haskell library for attack defense trees. It is designed with the
following goals in mind:

\todo{this feels too short}
\begin{itemize}
    \item To provide a \textbf{small and simple} interface for modelling attack
        defense trees while remaining \textbf{extendable}. \todo{mention no
        parser}
    \item To provide a \textbf{flexible} interface to \textbf{quantitative
        analysis} while providing some commonly used algebras.
    \item To \textbf{aid decision making} by generating minimal cutsets of the
        tree.
    \item To \textbf{visualise} any modelled tree.
\end{itemize}

ADTrees is inspired by ADTool \footnote{\url{https://github.com/tahti/ADTool2}},
a graphical interface developed in Java for creating and visualising attack
defense trees \cite{KordyTool}. While ADTool is a graphical tool, ADTrees is a
library: this contributes to keeping any superfluous functionality at minimum.
ADTrees also further simplifies the structure of countermeasure nodes. Both the
structure and the algebra of attack defense trees can be expressed cleanly
through Haskell's union types.

\subsection{Tree modelling}

Trees are represented by an inductive datatype. This datatype is generalised
over \texttt{a}, which may contain information of arbitrary type that is later
used for quantitative analysis. The leafs of the tree, represented by the
constructor \mintinline{Haskell}{Basic} contain this information. Constructors
\mintinline{Haskell}{And} and \mintinline{Haskell}{Or} represent logical gates
containing a list of subtrees. The constructor \mintinline{Haskell}{Counter}
represents a countermeasure: its left subtree contains actions by the same
player; its right subtree contains actions by its opponent.

\begin{code}
data ADTree a 
    = Basic   Name a
    | And     Name [ADTree a]
    | Or      Name [ADTree a]
    | Counter Name (ADTree a) (ADTree a)
\end{code}

The example ADT in Figure \ref{example-adt} carries information about the
probability and difficulty of each basic event. Such a tree can be represented
by the type \mintinline{Haskell}{ADTree (Fractional, Fractional)} and
represented as follows:

\label{example-model}
\begin{code}
Or "Bank Account" [
    And "ATM" [
        Or "PIN" [
            Basic "Eavesdrop" (0.01, 0.3),
            Counter "Get Note"
                (Basic "Find Note" (0.40, 0.3))
                (Basic "Memorize" (0.80, 0.1)),
            Basic "Force" (0.01, 0.9)],
        Basic "Card" (0.1, 0.7)],
    Counter "Online"
        (And "Login" [
            Or "Password" [
                Basic "Phishing" (0.90, 0.4),
                Basic "Key logger" (0.20, 0.6)],
            Basic "User name" (0.90, 0.1)])
        (Counter "2nd Auth Factor"
            (Or "Usage" [
                Basic "Key Fobs" (0.01, 0.1),
                Basic "PIN Pad" (0.01, 0.3)])
            (Or "Malware" [
                Basic "Browser" (0.20, 0.5),
                Basic "OS" (0.20, 0.4)]))]
\end{code}

\subsection{Quantitative analysis}

To perform quantitative analysis over customisable basic event attributes, the
user must be able to specify an algebra on them. There exist three cases which
this algebra has to take into consideration: OR gates, AND gates, and COUNTER
measures. Several such algebras exist \cite{KordyQuantitative}. ADTree exposes a
simplified interface for defining them:

\begin{code}
data PSemantics a = MkPSemantics
    { plus    :: a -> a -> a -- OR operator
    , zero    :: a           -- OR default
    , times   :: a -> a -> a -- AND operator
    , one     :: a           -- AND default
    , counter :: a -> a -> a -- COUNTER measure
    }
\end{code}

Algebras might need to change according to the player. For example, it might be
desirable to computer the cost just for the attacker's actions. This is
accommodated by making the algebra depend on the \mintinline{Haskell}{Player}:

\begin{code}
type Semantics a = Player -> PSemantics a
\end{code}

In the following example probability is defined -- which does not depend on who
the current player is, thus that argument is ignored:

\begin{code}
probability :: Semantics Rational
probability _ = MkPSemantics
    { plus    = \x y -> x + y - x * y
    , zero    = 0
    , times   = (*)
    , one     = 1
    , counter = (-)
    }
\end{code}

On the other hand, the difficulty for the attacker depends on the player of each
node:

\begin{code}
difficulty :: Semantics Rational
difficulty A = MkPSemantics
    { plus    = min
    , zero    = 1
    , times   = max
    , one     = 0
    , counter = max
    }
difficulty D = MkPSemantics
    { plus    = max
    , zero    = 0
    , times   = min
    , one     = 1
    , counter = min
    }
\end{code}

Other common algebras for quantitative analysis can be found in Appendix
\ref{algebras}.

Once a semantics is defined, an attack defense tree can be inductively
evaluated:

\begin{code}
evaluate :: Semantics a -> Player -> ADTree a -> a
evaluate _   _ (Basic _ a)
    = a
evaluate sem p (Or _ cs)
    = foldr (plus (sem p) . evaluate sem p) (zero $ sem p) cs
evaluate sem p (And _ cs)
    = foldr (times (sem p) . evaluate sem p) (one $ sem p) cs
evaluate sem p (Counter _ a d)
    = counter (sem p) (evaluate sem p a) (evaluate sem (switchPlayer p) d)
\end{code}

As shown in \ref{example-model}, attack defense trees may contain multiple
attributes. To facilitate the reuse of algebras, a tree with multiple attributes
can be translated into a tree with a single attribute, to which an already
defined algebra can be applied. This translation is possible because
\mintinline{Haskell}{ADTree a} follows the functor laws.

In the following example, \mintinline{Haskell}{fmap} applies a function to the
attributes of all \mintinline{Haskell}{Basic} events of a tree, while
\mintinline{Haskell}{snd} selects the second element of a tuple. Put together, a
tree with two attributes is translated into a tree with just the second of those
attributes:

\begin{code}
> :t example
    example :: ADTree (Rational, Rational)
> :t fmap snd example
    fmap snd example :: ADTree Rational
\end{code}

The user can then use the evaluation function as follows:

\begin{code}
> evaluate difficulty A (fmap snd example)
2 % 5
\end{code}

\subsection{Minimal cutsets}

\begin{code}
cutsets :: ADTree a -> [ADTree a]

cutsets (Basic n a) = [Basic n a]

-- Take the n-ary cartesian product of the children's cutsets,
-- then bind each product with an AND.
cutsets (And n es) = map (And n) (mapM cutsets es)

-- Append together the cutsets of all subtrees
cutsets (Or _ es) = concatMap cutsets es

-- Take the binary cartesian product of the attacker's and defender's cutsets,
-- then bind each product with a COUNTER measure
cutsets (Counter n a d) = Counter n <$> cutsets a <*> cutsets d
\end{code}

\todo{Decision making}

\subsection{Rendering}

ADTree uses Graphviz\footnote{\url{https://graphviz.org}} for tree rendering.
ADTree automatically translates a given tree into its Graphviz representation.
Then Graphviz can be used to transform this declarative description of a graph
into an image. The tree in Figure \ref{example-adt} is an example of this.
This idea was inspired by \textit{fault-tree}, a small Haskell library for fault
trees\footnote{\url{https://github.com/tomahawkins/fault-tree}}.

Assuming equality on attribute \texttt{a} is decidable, given a function that
translates any \texttt{a} into a string, and the player of the root node,
\mintinline{Haskell}{dot} will generate a Graphviz representation of an
\mintinline{Haskell}{ADTree a}:

\begin{code}
dot :: (Eq a) => (a -> String) -> Player -> ADTree a -> String
\end{code}

\chapter{Evaluation}
\label{evaluation}

\begin{figure}[h]
    \label{dns-transactions}
    \centering
    \includegraphics[width=\paperheight, angle=90]{dns}
    \caption{}
\end{figure}

% https://tools.ietf.org/html/rfc3833
% Showcase the tool with an example
% Underline how it helps implementing NIS
% We need to conduct some kind of experiment

% https://www.ofcom.org.uk/phones-telecoms-and-internet/information-for-industry/guidance-network-information-systems-regulations
% https://www.ncsc.gov.uk/information/active-cyber-defence-one-year
% https://www.theregister.co.uk/2017/08/17/uks_internet_operator_nominet_goes_dark/

\chapter{Results}
\label{results}

\todo{mention LOC}

\chapter{Conclusions}
\label{conclusions}

\bibliographystyle{apalike}
\bibliography{bibliography}

\newpage
\begin{appendices}
% Only display section titles in the TOC
\addtocontents{toc}{\protect\setcounter{tocdepth}{1}} 

\chapter{Source code}
% Where to obtain it
% How to install it
% A listing

\chapter{Algebras}
\label{algebras}

Following is a list of interesting predefined algebras suitable for quantitative
analysis:

\begin{code}
{-
   Probability of success, assuming all actions are mutually independent
-}
probability :: Semantics Rational
probability _ = MkPSemantics
    { plus    = \x y -> x + y - x * y
    , zero    = 0
    , times   = (*)
    , one     = 1
    , counter = (-)
    }

{-
   Difficulty for the attacker, assuming all attacker's actions are in place
-}
difficulty :: Semantics Rational
difficulty A = MkPSemantics
    { plus    = min
    , zero    = 1
    , times   = max
    , one     = 0
    , counter = max
    }
difficulty D = MkPSemantics
    { plus    = max
    , zero    = 0
    , times   = min
    , one     = 1
    , counter = min
    }

{-
   Minimal cost for the attacker, assuming that all attacker's actions are in
   place and that resources are not reused.
-}
cost :: Semantics Int
cost A = MkPSemantics
    { plus    = min
    , zero    = maxBound
    , times   = (+)
    , one     = 0
    , counter = (+)
    }
cost D = MkPSemantics
    { plus    = (+)
    , zero    = 0
    , times   = min
    , one     = maxBound
    , counter = min
    }

{-
   Minimal skill needed for the attacker, assuming that all attacker's actions
   are in place.
-}
skill :: Semantics Int
skill A = MkPSemantics
    { plus    = min
    , zero    = maxBound
    , times   = max
    , one     = minBound
    , counter = max
    }
skill D = MkPSemantics
    { plus    = max
    , zero    = minBound
    , times   = min
    , one     = minBound
    , counter = min
    }

{-
   Minimal time needed for the attacker, assuming that all attacker's actions
   are in place and that actions are executed in parallel.
-}
timeParallel :: Semantics Int
timeParallel A = MkPSemantics
    { plus    = min
    , zero    = maxBound
    , times   = max
    , one     = minBound
    , counter = max
    }
timeParallel D = MkPSemantics
    { plus    = max
    , zero    = minBound
    , times   = min
    , one     = minBound
    , counter = min
    }

{-
   Minimal time needed for the attacker, assuming that all attacker's actions
   are in place and that actions are executed in sequence.
-}
timeSequence :: Semantics Int
timeSequence A = MkPSemantics
    { plus    = min
    , zero    = maxBound
    , times   = (+)
    , one     = 0
    , counter = (+)
    }
timeSequence D = MkPSemantics
    { plus    = (+)
    , zero    = 0
    , times   = min
    , one     = minBound
    , counter = min
    }

{-
    Satisfiability of the scenario.
-}
satisfiability :: Semantics Bool
satisfiability _ = MkPSemantics
    { plus    = (||)
    , zero    = False
    , times   = (&&)
    , one     = True
    , counter = \x y -> x && not y
    }
\end{code}
\end{appendices}

\end{document}
